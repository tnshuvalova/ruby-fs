Searching 95 files for "THINK ABOUT IT"

/home/tshuvalova/projects/ruby_koans/koans/about_class_methods.rb:
  144    end
  145  
  146:   # THINK ABOUT IT:
  147    #
  148    # The two major ways to write class methods are:

/home/tshuvalova/projects/ruby_koans/koans/about_classes.rb:
  123        Dog6.new
  124      end
  125:     # THINK ABOUT IT:
  126      # Why is this so?
  127    end

/home/tshuvalova/projects/ruby_koans/koans/about_dice_project.rb:
   44        "Two rolls should not be equal"
   45  
   46:     # THINK ABOUT IT:
   47      #
   48      # If the rolls are random, then it is possible (although not

/home/tshuvalova/projects/ruby_koans/koans/about_hashes.rb:
   28      end
   29  
   30:     # THINK ABOUT IT:
   31      #
   32      # Why might you want to use #fetch instead of #[] when accessing hash keys?

/home/tshuvalova/projects/ruby_koans/koans/about_java_interop.rb:
   28    end
   29  
   30:   # THINK ABOUT IT:
   31    #
   32    # What if we use:
   ..
   75      assert_equal __, java_string == ruby_string
   76  
   77:     # THINK ABOUT IT:
   78      #
   79      # Is there any possible way for this to be more wrong?
   80      #
   81:     # SERIOUSLY, THINK ABOUT IT:
   82      #
   83      # Why do you suppose that Ruby and Java strings compare like that?
   84      #
   85:     # ADVANCED THINK ABOUT IT:
   86      #
   87      # Is there a way to make Ruby/Java string comparisons commutative?

/home/tshuvalova/projects/ruby_koans/koans/about_message_passing.rb:
   34      assert_equal __, mc.__send__(:caught?)
   35  
   36:     # THINK ABOUT IT:
   37      #
   38      # Why does Ruby provide both send and __send__ ?
   ..
   86      assert_match(/foobar/, exception.message)
   87  
   88:     # THINK ABOUT IT:
   89      #
   90      # If the method :method_missing causes the NoMethodError, then

/home/tshuvalova/projects/ruby_koans/koans/about_nil.rb:
   27      assert_equal "nil", nil.inspect
   28  
   29:     # THINK ABOUT IT:
   30      #
   31      # Is it better to use

/home/tshuvalova/projects/ruby_koans/koans/about_objects.rb:
   43      assert_equal 201, 100.object_id
   44  
   45:     # THINK ABOUT IT:
   46      # What pattern do the object IDs for small integers follow?
   47    end

/home/tshuvalova/projects/ruby_koans/koans/about_regular_expressions.rb:
   31      assert_equal __, "abbcccddddeeeee"[/z*/]
   32  
   33:     # THINK ABOUT IT:
   34      #
   35      # When would * fail to match?
   36    end
   37  
   38:   # THINK ABOUT IT:
   39    #
   40    # We say that the repetition operators above are "greedy."
   ..
  142    end
  143  
  144:   # THINK ABOUT IT:
  145    #
  146    # Explain the difference between a character class ([...]) and alternation (|).

/home/tshuvalova/projects/ruby_koans/koans/about_sandwich_code.rb:
   34  
   35    # ------------------------------------------------------------------
   36:   # THINK ABOUT IT:
   37    #
   38    # The count_lines and find_line are similar, and yet different.

/home/tshuvalova/projects/ruby_koans/koans/about_strings.rb:
   97      assert_equal "Hello, World", original_string
   98  
   99:     # THINK ABOUT IT:
  100      #
  101      # Ruby programmers tend to favor the shovel operator (<<) over the

/home/tshuvalova/projects/ruby_koans/koans/about_symbols.rb:
  # THINK ABOUT IT:
  #
  # Why do we convert the list of symbols to strings and then compare
  # against the string value rather than against symbols?
This has to do with how symbols work. For each symbol, only one of it actually exists. Behind the scenes, a symbol is just a number referred to by a name (starting with a colon). Thus, when comparing the equality of two symbols, you're comparing object identity and not the content of the identifier that refers to this symbol.
   ..
  # THINK ABOUT IT:
  #
  # Why is it not a good idea to dynamically create a lot of symbols?
Symbols are like strings but they are immutable - they can't be modified.
They are only put into memory once, making them very efficient to use for things like keys in hashes but they stay in memory until the program exits. This makes them a memory hog if you misuse them.

/home/tshuvalova/projects/ruby_koans/src/about_class_methods.rb:
  144    end
  145  
  146:   # THINK ABOUT IT:
  147    #
  148    # The two major ways to write class methods are:

/home/tshuvalova/projects/ruby_koans/src/about_classes.rb:
  123        Dog6.new
  124      end
  125:     # THINK ABOUT IT:
  126      # Why is this so?
  127    end

/home/tshuvalova/projects/ruby_koans/src/about_dice_project.rb:
   53        "Two rolls should not be equal"
   54  
   55:     # THINK ABOUT IT:
   56      #
   57      # If the rolls are random, then it is possible (although not

/home/tshuvalova/projects/ruby_koans/src/about_hashes.rb:
   28      end
   29  
   30:     # THINK ABOUT IT:
   31      #
   32      # Why might you want to use #fetch instead of #[] when accessing hash keys?

/home/tshuvalova/projects/ruby_koans/src/about_java_interop.rb:
   28    end
   29  
   30:   # THINK ABOUT IT:
   31    #
   32    # What if we use:
   ..
   75      assert_equal __(true), java_string == ruby_string
   76  
   77:     # THINK ABOUT IT:
   78      #
   79      # Is there any possible way for this to be more wrong?
   80      #
   81:     # SERIOUSLY, THINK ABOUT IT:
   82      #
   83      # Why do you suppose that Ruby and Java strings compare like that?
   84      #
   85:     # ADVANCED THINK ABOUT IT:
   86      #
   87      # Is there a way to make Ruby/Java string comparisons commutative?

/home/tshuvalova/projects/ruby_koans/src/about_message_passing.rb:
   34      assert_equal __(true), mc.__send__(:caught?)
   35  
   36:     # THINK ABOUT IT:
   37      #
   38      # Why does Ruby provide both send and __send__ ?
   ..
   86      assert_match(/foobar/, exception.message) # __
   87  
   88:     # THINK ABOUT IT:
   89      #
   90      # If the method :method_missing causes the NoMethodError, then

/home/tshuvalova/projects/ruby_koans/src/about_nil.rb:
   27      assert_equal __("nil"), nil.inspect
   28  
   29:     # THINK ABOUT IT:
   30      #
   31      # Is it better to use

/home/tshuvalova/projects/ruby_koans/src/about_objects.rb:
   43      assert_equal __(201), 100.object_id
   44  
   45:     # THINK ABOUT IT:
   46      # What pattern do the object IDs for small integers follow?
   47    end

/home/tshuvalova/projects/ruby_koans/src/about_regular_expressions.rb:
     # THINK ABOUT IT:
     #
     # When would * fail to match?
      end
  Since * will always accept the empty string, it will only fail if you have something before or after it that doesn't match. For example, ab*c will fail to match azc, since b* will not match z and c will not match zc.

  # THINK ABOUT IT:
  #
  # We say that the repetition operators above are "greedy."
  #
  # Why?

  143  
  144:   # THINK ABOUT IT:
  145    #
  146    # Explain the difference between a character class ([...]) and alternation (|).

/home/tshuvalova/projects/ruby_koans/src/about_sandwich_code.rb:
   34  
   35    # ------------------------------------------------------------------
   36:   # THINK ABOUT IT:
   37    #
   38    # The count_lines and find_line are similar, and yet different.

/home/tshuvalova/projects/ruby_koans/src/about_strings.rb:
   97      assert_equal __("Hello, World"), original_string
   98  
   99:     # THINK ABOUT IT:
  100      #
  101      # Ruby programmers tend to favor the shovel operator (<<) over the

/home/tshuvalova/projects/ruby_koans/src/about_symbols.rb:
   29    end
   30  
   31:   # THINK ABOUT IT:
   32    #
   33    # Why do we convert the list of symbols to strings and then compare
   ..
   95    end
   96  
   97:   # THINK ABOUT IT:
   98    #
   99    # Why is it not a good idea to dynamically create a lot of symbols?


# Bonus Question:  In the previous koan, we saw the construct:
  #
  #   File.open(filename) do |file|
  #     # code to read 'file'
  #   end
  #
  # Why did we do it that way instead of the following?
  #
  #   file = File.open(filename)
  #   # code to read 'file'
  #
  # When you get to the "AboutSandwichCode" koan, recheck your answer.
 Please check the online documentation for a full list of modes available. File.open opens a new File if there is no associated block. If the optional block is given, it will be passed file as an argument, and the file will automatically be closed when the block terminates. Always close a file that you open. In the case of a file open for writing, this is very important and can actually prevent lost data. 